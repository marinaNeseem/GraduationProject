
const itemModel = require('../modules/ItemModel');
const UserModel = require('../modules/UserModel');
const CategoryModel= require('../modules/CategoryModel');
const slugify = require('slugify');
const asyncHandler = require('express-async-handler');
const multer = require('multer');
const jwt = require('jsonwebtoken');
const mongoose = require('mongoose');
const { populate } = require('../modules/ItemModel');
const ItemModel = require('../modules/ItemModel');


//Create item
const storage = multer.diskStorage({
  destination: function (req, file, cb) {
      cb(null, 'uploads/'); // Save the uploaded files to the 'uploads' directory
  },
  filename: function (req, file, cb) {
      cb(null, file.fieldname + '-' + Date.now() + '.' + file.originalname.split('.').pop());
  }
});

const upload = multer({ storage: storage });

exports.createItem = asyncHandler(async (req, res) => {
  upload.single('image')(req, res, async (err) => {
      if (err) {
          console.log(err);
          return res.status(400).json({ success: false, message: "Error uploading image" });
      }

      // Extract token from request headers
      const token = req.headers.token;

      // Check if token exists
      if (!token) {
          return res.status(401).json({ success: false, message: 'Unauthorized: No token provided' });
      }

      try {
          // Verify token
          const decoded = jwt.verify(token, 'your_secret_key');
          const userId = decoded.userId;

          const { title, Descreption, price, category, phone, condition, status } = req.body;

          // Construct the complete URL for the image
          const imageUrl = req.file ?` ${req.protocol}://${req.get('host')}/${req.file.path}` : null;

          // Create new item associated with the user identified by the token
          const item = await itemModel.create({
              title,
              slug: slugify(title),
              Descreption,
              user: userId, // Associate the item with the user identified by the token
              category,
              price,
              phone,
              condition,
              status,
              image: imageUrl // Save the constructed URL of the uploaded image
          });

          res.status(201).json({ success: true, data: item });

      } catch (error) {
          // Handle Mongoose validation errors
          if (error instanceof mongoose.Error.ValidationError) {
              const errors = Object.values(error.errors).map((val) => val.message);
              return res.status(400).json({ success: false, message: errors });
          }

          console.log(error);
          res.status(500).json({ success: false, message: 'Internal Server Error' });
      }
  });
});




 //Get all items
exports.getItems = asyncHandler(async (req, res) => {
  //req from user as params (pages, limit)
  const page = req.query.page * 1 || 1; // to convert string to number(query returns string)
  const limit = req.query.limit * 1 || 5;
  const skip = (page - 1) * limit;
  const items = await itemModel.find({})
      .skip(skip)
      .limit(limit)
      .populate('category', '_id name'); // Populate the 'category' field and retrieve both '_id' and 'name'

  const formattedItems = items.map(item => ({
      _id: item._id,
      title: item.title,
      description: item.description,
      price: item.price,
      Category: {
          _id: item.category._id, // Retrieve category ID
          name: item.category.name // Retrieve category name
      },
      user: item.user,
      condition: item.condition,
      slug: item.slug,
      image: item.image,
      status: item.status,
      createdAt: item.createdAt,
      updatedAt: item.updatedAt
  }));

  res.status(200).json({ TotalItems: items.length, page, data: formattedItems });
});


  //get spisific item by id

exports.getItem = asyncHandler(async (req, res) => {
    const { id } = req.params;
    if (!mongoose.Types.ObjectId.isValid(id)) {
        return res.status(400).json({ msg: 'Invalid ID format' });
    }

    const item = await itemModel.findById(id);
    if (!item) {
        return res.status(404).json({ msg: `No item found for this id ${id}` });
    }
    res.status(200).json({ data: item });
});

//to get specific item by name
exports.getItemByName = asyncHandler(async (req, res) => {
  const { title } = req.params;
  
  const item = await itemModel.findOne({ title });
  if (!item) {
      return res.status(404).json({ msg: `No item found with name '${title}'` });
  }
  res.status(200).json({ data: item });
});

//to update specific item

exports.updateitem = asyncHandler(async (req, res) => {
  const { id } = req.params;
  const { token } = req.headers;
  const { title, price, Descreption, category, condition } = req.body;

  // Check if token exists
  if (!token) {
      return res.status(401).json({success: false, msg: 'Unauthorized: No token provided' });
  }

  try {
      // Verify token
      const decoded = jwt.verify(token, 'your_secret_key');
      const userId = decoded.userId;

      // Retrieve the item from the database
      const itemToUpdate = await itemModel.findById(id);

      // Check if the item exists
      if (!itemToUpdate) {
          return res.status(404).json({success: false, msg: `No item found for this id: ${id}` });
      }

      // Check if the user is authorized to update the item
      if (itemToUpdate.user.toString() !== userId) {
          return res.status(403).json({success: false, msg: 'You are not authorized to update this item' });
      }

      // Generate slug from title
      const slug = slugify(title);

      // Update the item
      const updatedItem = await itemModel.findByIdAndUpdate(
          id,
          { title, slug, price, Descreption, category, condition },
          { new: true }
      );

      // Check if the item was successfully updated
      if (!updatedItem) {
          return res.status(500).json({success: false, msg: 'Failed to update item' });
      }

      res.status(200).json({ success:true ,data: updatedItem });
  } catch (error) {
      console.error(error); // Log the error for debugging
      return res.status(401).json({ success: false,msg: 'Unauthorized: Invalid token' });
  }
});
// delete spicific item
exports.deleteitem = asyncHandler(async (req, res) => {
  const { id } = req.params;
  const { token } = req.headers;

  // Check if token exists
  if (!token) {
      return res.status(401).json({ success: false,msg: 'Unauthorized: No token provided' });
  }

  try {
      // Verify token
      const decoded = jwt.verify(token, 'your_secret_key');
      const userId = decoded.userId;

      // Retrieve the item from the database
      const itemToDelete = await itemModel.findById(id);

      // Check if the item exists
      if (!itemToDelete) {
          return res.status(404).json({success: false, msg: `No item found for this id: ${id}` });
      }

      // Check if the user is authorized to delete the item
      if (itemToDelete.user.toString() !== userId) {
          return res.status(403).json({ success: false , msg: 'You are not authorized to delete this item' });
      }

      // Delete the item
      await itemModel.findByIdAndDelete(id);

      res.status(200).json({success: true , msg: `The item with ID ${id} was successfully deleted` });
  } catch (error) {
      console.error('Error deleting item:', error);
      return res.status(500).json({success: false , msg: 'Internal server error' });
  }
});



//ADD ITEM TO SAVED ITEMS

exports.addToSavedItems = asyncHandler(async (req, res) => {
  try {
    const itemId = req.params.itemId; // Extract itemId from request parameters
    const token = req.headers.token; // Extract token from request headers

    // Check if both item ID and token are provided
    if (!itemId || !token) {
      return res.status(400).json({ error: 'Item ID and token are required' });
    }

    // Verify token
    const decoded = jwt.verify(token, 'your_secret_key');
    const userId = decoded.userId;

    // Check if the item exists
    const item = await itemModel.findById(itemId);
    if (!item) {
      return res.status(404).json({ error: 'Item not found' });
    }

    // Check if the user exists
    const user = await UserModel.findById(userId);
    if (!user) {
      return res.status(404).json({ error: 'User not found' });
    }

    // Ensure the favorites array is initialized
    if (!user.favorites) {
      user.favorites = [];
    }

    // Check if the item is already in user's favorites
    if (user.favorites.includes(itemId)) {
      return res.status(400).json({ error: 'Item already in favorites' });
    }

    // Add the item to user's favorites
    user.favorites.push(itemId);
    await user.save();

    res.status(200).json({ message: 'Item added to favorites successfully' });
  } catch (error) {
    console.error('Error adding item to favorites:', error);
    res.status(500).json({ error: 'Failed to add item to favorites' });
  }
});

  



// List all saved items of a user
// LIST SAVED ITEMS
exports.listSavedItems = asyncHandler(async (req, res) => {
  try {
    const token = req.headers.token; // Extract token from request headers

    // Check if token is provided
    if (!token) {
      return res.status(400).json({ error: 'Token is required' });
    }

    // Verify token
    const decoded = jwt.verify(token, 'your_secret_key');
    const userId = decoded.userId;

    // Find user by ID
    const user = await UserModel.findById(userId).populate('favorites');

    // Check if the user exists
    if (!user) {
      return res.status(404).json({ error: 'User not found' });
    }

    // Check if favorites array is empty
    if (!user.favorites || user.favorites.length === 0) {
      return res.status(200).json({ message: 'Saved items list is empty' });
    }

    // Return the list of saved items
    res.status(200).json({ data: user.favorites });
  } catch (error) {
    console.error('Error listing saved items:', error);
    res.status(500).json({ error: 'Failed to list saved items' });
  }
});



//search



exports.search = asyncHandler(async (req, res) => {
  const page = parseInt(req.query.page) || 1;
  const limit = parseInt(req.query.limit) || 5;
  const skip = (page - 1) * limit;

  
  const search = {};
  if (req.query.search) {
    search.title = { $regex: req.query.search, $options: 'i' }; // Case-insensitive partial match
  }

  const item = await itemModel.find(search)
  .skip(skip)
  .limit(limit)
  .populate({ path: 'category' , select :"name" });

  res.status(200).json({ page, limit, results: item.length, data: item });
});



//recentyly posted items & list items without limit and skip(see All)
exports.RecentItems= asyncHandler(async (req, res) => {
  const items = await ItemModel.find({})
      .sort({ createdAt: -1 }) ;// Sort by createdAt field in descending order (most recent to oldest)

      

  const formattedItems = items.map(item => ({
      _id: item._id,
      title: item.title,
      Descreption: item.Descreption,
      price: item.price,
      Category: {
          _id: item.category._id, // Retrieve category ID
          name: item.category.name // Retrieve category name
      },
      user: item.user,
      condition: item.condition,
      slug: item.slug,
      image: item.image,
      status: item.status,
      createdAt: item.createdAt.toISOString(), // Convert createdAt timestamp to ISO string
      updatedAt: item.updatedAt
  }));

  res.status(200).json({
      success: true,
      count: formattedItems.length,
      data: formattedItems
  });
});
//ALL USER'S ACCEPTED ITEMS WITH HIS ID

exports.GetUserAcceptedItems = asyncHandler(async (req, res) => {
    const userId = req.params.userId; // Assuming the user ID is provided in the request parameters

    const items = await ItemModel.find({
        user: userId,
        status: 'accepted' // Filter by status 'accepted'
    }).sort({ createdAt: -1 });

    const formattedItems = [];
    for (const item of items) {
        // Find category name by category ID
        const category = await CategoryModel.findById(item.category);
        formattedItems.push({
            _id: item._id,
            title: item.title,
            Descreption: item.Descreption,
            price: item.price,
            Category: category ? { // Check if category is found
                _id: category._id,
                name: category.name
            } : null,
            user: item.user,
            condition: item.condition,
            slug: item.slug,
            image: item.image,
            status: item.status,
            createdAt: item.createdAt.toISOString(),
            updatedAt: item.updatedAt
        });
    }

    res.status(200).json({
        success: true,
        count: formattedItems.length,
        data: formattedItems
    });
});
